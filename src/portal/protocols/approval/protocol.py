"""
Approval Protocol Implementation
=================================

Provides interface-agnostic human approval for sensitive operations.
"""

import asyncio
import logging
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

from portal.core.event_bus import Event, EventBus, EventType

logger = logging.getLogger(__name__)


class ApprovalStatus(Enum):
    """Status of an approval request"""
    PENDING = "pending"
    APPROVED = "approved"
    DENIED = "denied"
    TIMEOUT = "timeout"


@dataclass
class ApprovalRequest:
    """
    Request for human approval

    This is generated by the agent when it needs approval
    for a sensitive operation.
    """
    request_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    chat_id: str = ""
    user_id: str | None = None
    operation: str = ""
    description: str = ""
    context: dict[str, Any] = field(default_factory=dict)
    timeout_seconds: int = 300  # 5 minutes default
    created_at: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary"""
        return {
            'request_id': self.request_id,
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'operation': self.operation,
            'description': self.description,
            'context': self.context,
            'timeout_seconds': self.timeout_seconds,
            'created_at': self.created_at.isoformat()
        }


@dataclass
class ApprovalDecision:
    """
    Decision from human

    This is returned by the interface after the human makes a decision.
    """
    request_id: str
    status: ApprovalStatus
    user_id: str | None = None
    reason: str | None = None
    decided_at: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary"""
        return {
            'request_id': self.request_id,
            'status': self.status.value,
            'user_id': self.user_id,
            'reason': self.reason,
            'decided_at': self.decided_at.isoformat()
        }


class ApprovalProtocol:
    """
    Approval protocol coordinator

    Manages the flow of approval requests and decisions
    between the agent and interfaces.

    Architecture:
    1. Agent calls request_approval()
    2. Protocol emits APPROVAL_REQUESTED event
    3. Interface subscribes to event and renders UI
    4. User makes decision via interface
    5. Interface calls submit_decision()
    6. Protocol resolves the future and returns decision to agent
    """

    def __init__(self, event_bus: EventBus):
        """
        Initialize approval protocol

        Args:
            event_bus: Event bus for publishing/subscribing
        """
        self.event_bus = event_bus
        self._pending_requests: dict[str, asyncio.Future] = {}

        logger.info("ApprovalProtocol initialized")

    async def request_approval(
        self,
        chat_id: str,
        operation: str,
        description: str,
        user_id: str | None = None,
        context: dict[str, Any] | None = None,
        timeout_seconds: int = 300
    ) -> ApprovalDecision:
        """
        Request approval from human

        Args:
            chat_id: Chat/conversation ID
            operation: Operation name (e.g., "delete_file", "execute_code")
            description: Human-readable description
            user_id: Optional user ID
            context: Optional additional context
            timeout_seconds: Timeout in seconds (default 5 minutes)

        Returns:
            ApprovalDecision with user's decision

        Example:
            decision = await protocol.request_approval(
                chat_id="123",
                operation="delete_file",
                description="Delete /important/data.txt",
                context={"file_path": "/important/data.txt"}
            )

            if decision.status == ApprovalStatus.APPROVED:
                # Proceed with operation
                ...
        """
        # Create request
        request = ApprovalRequest(
            chat_id=chat_id,
            user_id=user_id,
            operation=operation,
            description=description,
            context=context or {},
            timeout_seconds=timeout_seconds
        )

        # Create future for decision
        future = asyncio.get_event_loop().create_future()
        self._pending_requests[request.request_id] = future

        # Emit event for interfaces
        event = Event(
            event_type=EventType.TOOL_CONFIRMATION_REQUIRED,
            chat_id=chat_id,
            timestamp=datetime.utcnow().isoformat(),
            data=request.to_dict()
        )
        await self.event_bus.publish(event)

        logger.info(
            f"Approval requested: {operation}",
            request_id=request.request_id,
            chat_id=chat_id
        )

        try:
            # Wait for decision with timeout
            decision = await asyncio.wait_for(
                future,
                timeout=timeout_seconds
            )
            logger.info(
                f"Approval received: {decision.status.value}",
                request_id=request.request_id,
                chat_id=chat_id
            )
            return decision

        except TimeoutError:
            # Timeout - auto-deny
            logger.warning(
                f"Approval timeout: {operation}",
                request_id=request.request_id,
                chat_id=chat_id
            )

            decision = ApprovalDecision(
                request_id=request.request_id,
                status=ApprovalStatus.TIMEOUT,
                reason="No response within timeout period"
            )

            # Clean up
            self._pending_requests.pop(request.request_id, None)

            # Emit timeout event
            timeout_event = Event(
                event_type=EventType.TOOL_CONFIRMATION_DENIED,
                chat_id=chat_id,
                timestamp=datetime.utcnow().isoformat(),
                data=decision.to_dict()
            )
            await self.event_bus.publish(timeout_event)

            return decision

    async def submit_decision(self, decision: ApprovalDecision):
        """
        Submit a decision from an interface

        This is called by interfaces when the user makes a decision.

        Args:
            decision: The user's decision
        """
        request_id = decision.request_id

        if request_id not in self._pending_requests:
            logger.warning(
                f"Decision for unknown request: {request_id}",
                status=decision.status.value
            )
            return

        # Resolve the future
        future = self._pending_requests.pop(request_id)
        if not future.done():
            future.set_result(decision)

        # Emit decision event

        # Get chat_id from any pending request context
        # (we need to emit an event, so we need the chat_id)
        # For simplicity, we'll log but not emit if we don't have it
        logger.info(
            f"Decision submitted: {decision.status.value}",
            request_id=request_id
        )

    def get_pending_requests(self, chat_id: str | None = None) -> dict[str, ApprovalRequest]:
        """
        Get pending approval requests

        Args:
            chat_id: Optional filter by chat_id

        Returns:
            Dictionary of request_id -> ApprovalRequest
        """
        # Note: This is a simplified implementation
        # In a full implementation, we'd store the original requests
        return {}


def create_approval_protocol(event_bus: EventBus) -> ApprovalProtocol:
    """
    Factory function to create an approval protocol

    Args:
        event_bus: Event bus instance

    Returns:
        ApprovalProtocol instance
    """
    return ApprovalProtocol(event_bus)
